#include "Allfunc.h"
vector<int> ADD_NN_N(vector<int> a, vector<int> b)
{

	if (COM_NN_D(a, b) == 2)      // 2 если a>b, 0 если a=b, 1 если a<b
	{
		reverse(a.begin(), a.end());//читаем вектор справа налево
		reverse(b.begin(), b.end());//читаем вектор справа налево
		b.resize((a.size() + 1), 0);//Обновляем размер вектора, который хранит резльтат сложения, и назначим ему размерность большего числа 
		for (int ix = 0; ix < ((b.size() - 1)); ix++)
		{
			b[ix] += a[ix]; // суммируем последние разряды чисел
			b[ix + 1] += (b[ix] / 10); // если есть разряд для переноса, переносим его в следующий разряд
			b[ix] %= 10; // если есть разряд для переноса он отсекается
		}

		if (b[b.size() - 1] == 0)//если последняя цифра(первая в исходном числе) является нулем,то удаляем его,как незначащий
			b.pop_back();
		reverse(b.begin(), b.end());// читаем итоговую сумму слева направо
	}
	else {

		reverse(a.begin(), a.end());//читаем вектор справа налево
		reverse(b.begin(), b.end());//читаем вектор справа налево
		b.resize((a.size() + 1), 0);//Обновляем размер вектора, который хранит резльтат сложения, и назначим ему размерность большего числа 
		for (int ix = 0; ix < (b.size() - 1); ix++)
		{

			b[ix] += a[ix]; // суммируем последние разряды чисел
			b[ix + 1] += (b[ix] / 10); // если есть разряд для переноса, переносим его в следующий разряд
			b[ix] %= 10; // если есть разряд для переноса он отсекается
		}

		if (b[b.size() - 1] == 0)//если последняя цифра(первая в исходном числе) является нулем,то удаляем его,как незначащий
			b.pop_back();
		reverse(b.begin(), b.end());// читаем итоговую сумму слева направо
	}
	return (b);
}